mod cli;
mod config;
mod errors;
mod generator;
mod reload;
mod state;
mod symlink;
mod theme;

use clap::CommandFactory;
use clap_complete::{generate, shells};
use cli::{Cli, Commands, Shell};
use config::Config;
use errors::Result;
use generator::ThemeGenerator;
use reload::ReloadDispatcher;
use state::State;
use std::io;
use symlink::SymlinkManager;
use theme::Theme;

fn main() {
    if let Err(e) = run() {
        eprintln!("Error: {}", e);
        std::process::exit(1);
    }
}

fn run() -> Result<()> {
    let cli = Cli::parse_args();

    match cli.command {
        Commands::Switch => handle_switch()?,
        Commands::Theme { name } => handle_theme(name)?,
        Commands::List => handle_list()?,
        Commands::Status => handle_status()?,
        Commands::Completions { shell } => handle_completions(shell)?,
    }

    Ok(())
}

fn handle_switch() -> Result<()> {
    // Load current state and config
    let mut state = State::load()?;
    let config = Config::load()?;

    // Automatically toggle to opposite variant
    let old_variant = state.current_variant.clone();
    let variant = if old_variant == "dark" {
        "light".to_string()
    } else {
        "dark".to_string()
    };

    println!(
        "Switching from '{}' to '{}' variant...",
        old_variant, variant
    );

    // Update variant in state
    state.current_variant = variant.clone();

    // Verify theme-variant exists (configs pre-generated by Nix)
    let generator = ThemeGenerator::new();
    generator.verify_theme_variant_exists(&state.current_theme, &variant)?;

    // Update the 'current' symlink to point to the new theme-variant
    let symlink_manager = SymlinkManager::new();
    symlink_manager.update_current_symlink(&state.current_theme, &variant)?;

    // Save state
    state.save()?;

    // Reload applications
    let reload_dispatcher = ReloadDispatcher::new();
    reload_dispatcher.reload_apps(&config)?;

    println!(
        "Successfully switched from '{}' to '{}' variant",
        old_variant, variant
    );

    Ok(())
}

fn handle_theme(name: String) -> Result<()> {
    // Load current state and config
    let mut state = State::load()?;
    let config = Config::load()?;

    println!(
        "Switching from '{}' to '{}' theme...",
        state.current_theme, name
    );

    // Update theme in state
    let old_theme = state.current_theme.clone();
    state.current_theme = name.clone();

    // Verify theme-variant exists (configs pre-generated by Nix)
    let generator = ThemeGenerator::new();
    generator.verify_theme_variant_exists(&name, &state.current_variant)?;

    // Update the 'current' symlink to point to the new theme-variant
    let symlink_manager = SymlinkManager::new();
    symlink_manager.update_current_symlink(&name, &state.current_variant)?;

    // Save state
    state.save()?;

    // Reload applications
    let reload_dispatcher = ReloadDispatcher::new();
    reload_dispatcher.reload_apps(&config)?;

    println!(
        "Successfully switched from '{}' to '{}' theme",
        old_theme, name
    );

    // Console palette is automatically reloaded via setvtrgb

    Ok(())
}

fn handle_list() -> Result<()> {
    println!("Available themes:");
    let themes = Theme::discover_themes()?;

    if themes.is_empty() {
        println!("  (no themes found)");
        println!();
        println!("Add themes to your NixOS/home-manager configuration.");
        println!("See docs/theming.md for details.");
    } else {
        for theme in themes {
            println!("  â€¢ {}", theme);
        }
    }

    Ok(())
}

fn handle_status() -> Result<()> {
    let state = State::load()?;

    // Save state to ensure state file exists
    state.save()?;

    println!("Current theme: {}", state.current_theme);
    println!("Current variant: {}", state.current_variant);

    if let Some(last_applied) = state.last_applied {
        println!("Last applied: {}", last_applied);
    }

    Ok(())
}

fn handle_completions(shell: Shell) -> Result<()> {
    let mut cmd = Cli::command();
    let bin_name = "vogix";

    match shell {
        Shell::Bash => {
            generate(shells::Bash, &mut cmd, bin_name, &mut io::stdout());
        }
        Shell::Zsh => {
            generate(shells::Zsh, &mut cmd, bin_name, &mut io::stdout());
        }
        Shell::Fish => {
            generate(shells::Fish, &mut cmd, bin_name, &mut io::stdout());
        }
        Shell::Pwsh => {
            generate(shells::PowerShell, &mut cmd, bin_name, &mut io::stdout());
        }
        Shell::Elvish => {
            generate(shells::Elvish, &mut cmd, bin_name, &mut io::stdout());
        }
    }

    Ok(())
}
